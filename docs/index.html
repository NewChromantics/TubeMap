<html>
<head>

<style>
/*@import "Editor.css";*/

:root
{
	--NewColour:			#5d5;
	--InfoBoxColour:		#beb;
	--InfoBoxColourDark:	#2a2;
	
	--northern:				#222;
	--circle:				#ec4;
	--metropolitan:			#915;
	--hammersmith-city:		#e8a;
	--piccadilly:			#238;
	--overground:			#fa0;
	--central:				#e11;
	--jubilee:				#aab;	/* very slight tint from grey*/
	--waterloo-city:		#7c9;
	--district:				#153;
	--bakerloo:				#851;
	--victoria:				#29f;
	--dlr:					#7c9;
}

body
{
	background:		#eee;
	font-family:	sans-serif;
	font-size:		10pt;
	font-weight:	bold;
}
/*
#TrainList
{
	--CellMinSize:			10vw;
	--CellMaxSize:			30vw;
	display:				grid;
	xxxgrid-template-columns:	repeat(auto-fit, minmax( var(--CellMinSize), var(--CellMaxSize) ) );
	grid-gap:				2vmin;
	grid-template-columns:	1fr;
}
*/

#TrainList:empty:before
{
	content:	"Loading train list...";
}


#TrainList *
{
	--LineColour:	lime;	/* default */
}

#TrainList *[Line=northern]			{	--LineColour:	var(--northern);	}
#TrainList *[Line=circle]			{	--LineColour:	var(--circle);	}
#TrainList *[Line=metropolitan]		{	--LineColour:	var(--metropolitan);	}
#TrainList *[Line=hammersmith-city]	{	--LineColour:	var(--hammersmith-city);	}
#TrainList *[Line=piccadilly]		{	--LineColour:	var(--piccadilly);	}
#TrainList *[Line=overground]		{	--LineColour:	var(--overground);	}
#TrainList *[Line=central]			{	--LineColour:	var(--central);	}
#TrainList *[Line=jubilee]			{	--LineColour:	var(--jubilee);	}
#TrainList *[Line=waterloo-city]	{	--LineColour:	var(--waterloo-city);	}
#TrainList *[Line=district]			{	--LineColour:	var(--district);	}
#TrainList *[Line=bakerloo]			{	--LineColour:	var(--bakerloo);	}
#TrainList *[Line=victoria]			{	--LineColour:	var(--victoria);	}
#TrainList *[Line=dlr]				{	--LineColour:	var(--dlr);	}



#TrainList *
{
	color:				var(--LineColour);
	background-color:	white;
}

#TrainList *[Arrived],
#TrainList *[Expired]
{
	color:				white;
	background-color:	var(--LineColour);
}

/* only display seconds if not blank, otherwise padding makes it visible */
#TrainList *:after
{
	display:			inline-block;
	content:			attr(SecsToArrive);
	background-color:	#eee;
	color:				#ccc;
	width:				3em;
	margin-left:		0.6em;
	padding:			0.3em;
	font-size:			70%;
	overflow:			hidden;
}

#TrainList *:after[SecsToArrive=""]
{
	display:	none;
}


#TrainList *:before
{
	display:			inline-block;
	content:			attr(Line);
	background-color:	var(--LineColour);
	color:				#eee;
	width:				8em;
	text-align:			center;
	margin:				0.3em;
	margin-right:		0.6em;
	padding:			0.3em;
	font-size:			70%;
	overflow:			hidden;
	
	/* vertically center without throwing off the main content */
	display:			inline-flex;
	align-items:		center;
	justify-content:	center;
}

#TrainList *[New]:after
{
	content:		"new!";
	text-align:			center;
	color:			var(--NewColour);
}

#TrainList *[Expired]
{
	--LineColour:	#ccc;
}
/*
#TrainList *[New]
{
	--LineColour:	#0f0;
}
*/
/*
#TrainList 
{
	color:	yellow;
}

#TrainList *[New]
{
	color:	lime;
}

#TrainList *[Arrived]
{
	color:	red;
}

#TrainList *[Expired]
{
	color:	black;
}
*/

.InfoBox
{
	--Colour:		var(--InfoBoxColour);
	--DarkColour:	var(--InfoBoxColourDark);
	background:		var(--Colour);
	color:			var(--DarkColour);
	margin:			1em;
	border:			1px solid var(--DarkColour);
	padding:		0.6em;
	
	position:		absolute;
	top:			0px;
	right:			0px;
	
	font-size:		90%;
}
.InfoBox:empty
{
	display:	none;
}

</style>
</head>
<body>

<h1>Next trains arriving</h1>
<div class="InfoBox"></div>

<div id="TrainList"></div>

<script type=module>

import * as Pop from './PopUtils.js'

import {StationStopPoints,StationFormattedNames,LineFormattedNames} from './Stations.js'



const TrainNewTimeSecs = 5;
const TrainWaitTimeSecs = 13;
const ThrottleUpdateNextSecs = 3;
const ThrottleUpdateAllSecs = 600;


//	filtering only these modes
const ModeNames = 
[
'overground',
'tube',
'dlr'
];



const TrainData = [];

function GetStationUrl(StopPoint)
{
	return `https://api.tfl.gov.uk/StopPoint/${StopPoint}/Arrivals`;
}

async function GetStationJson(StationCode)
{
	const StopPoint = StationStopPoints[StationCode];
	const Url = GetStationUrl(StopPoint);
	
	const headers = new Headers();
	//headers.append('Access-Control-Allow-Origin','*');
	
	const FetchParams = {};
	//FetchParams.mode = 'no-cors';
	FetchParams.mode = 'cors';
	FetchParams.headers = headers;
	//FetchParams.redirect = 'follow';
	
	const Response = await fetch( Url, FetchParams );
	//const TextPromise = Response.text();
	const JsonPromise = Response.json();
	//const Body = await TextPromise;
	const Json = await JsonPromise;
	
	return Json;
}

function GetTimeNowSecs()
{
	const Ms = Date.now();
	//return Math.floor(Pop.GetTimeNowMs() / 1000);
	const Secs = Math.floor( Ms / 1000 );
	return Secs %1000;
}

function TimestampToTimeSecs(DateString)
{
	//2021-06-20T15:26:19Z
	const DateValue = Date.parse(DateString);
	const Secs = DateValue.getTime();
	return Secs % 1000;
}

//	parse XML
/*
 <S Code="CTN" Mess="" N="Camden Town." CurTime="15:45:59">
",<P N="Northbound - Platform 1" Num="1" TrackCode="TN60164" NextTrain="false">
",  <T TrainId="2943082" LCID="141" SetNo="054" TripNo="11" SecondsTo="0" TimeTo="-" Location="At Platform" Destination="Edgware via CX" InputDest="EDG3-X (EDG3//EDG3-X) [EDG3=X/EDG3=X]" DestCode="153" Order="0" DepartTime="14:45:33" DepartInterval="0" Departed="0" Direction="0" IsStalled="0" TrackCode="TN60165" LN="N" LeadingCarNo="51641" />
", */
async function GetStationTrains(StationJson,StationCode,FetchTimeSecs)
{
	function MinimiseTrain(TrainData)
	{
		//	filter out non underground/overground trains
		if ( ModeNames.indexOf(TrainData.modeName) == -1 )
		{
			console.log(`Filtered out train mode ${TrainData.modeName}`);
			return null;
		}
			
		const Train = {};
		Train.AddedTime = FetchTimeSecs;
		Train.ArrivalTime = FetchTimeSecs + TrainData.timeToStation;
		Train.Line = LineFormattedNames[TrainData.lineId] || TrainData.lineId;
		Train.Station = StationFormattedNames[StationCode];
		Train.PredictionId = TrainData.id;	//	seems to be unique (string)
		
		//	"delete this data from your cache"
		if ( TrainData.operationType == 2 )
		{
			console.log(`Got Delete Cache operation; ${JSON.stringify(TrainData)}`);
			Train.ArrivalTime = null;
		}
		
		return Train;
	}
	
	const Trains = StationJson.map(MinimiseTrain).filter( t => t!=null );
	return Trains;
	/*
	//	regex for xml 
	const TrainPattern = `<T [.*] TimeTo="(.*)"[.*]/>`;
	const TrainMatches = [...Xml.matchAll(TrainPattern)];
	
	function MatchToTrain(Match)
	{
		const Train = {};
		Train.ArrivalTime = Match[1];
		return Train;
	}
	const Trains = TrainMatches.map(MatchToTrain);
	return Trains;
	*/
}

function UpdateTrainDom(Train)
{
	const Div = document.createElement('div');
	Div.innerText = Train;
	document.body.appendChild(Div);
}

function PushTrainData(Train)
{
	function MatchTrain(OldTrain)
	{
		//	arrival time changes too much, use the predicition id
		return OldTrain.PredictionId == Train.PredictionId;
		/*
		if ( OldTrain.ArrivalTime != Train.ArrivalTime )
			return false;
		if ( OldTrain.Line != Train.Line )
			return false;
		if ( OldTrain.Station != Train.Station )
			return false;
		*/
		return true;
	}
	
	//	insert into train data, but detect duplicate
	const ExistingTrain = TrainData.find(MatchTrain);
	if ( ExistingTrain )
		return;
	
	//	make element
	const TrainListElement = document.querySelector('#TrainList');
	const TrainElement = document.createElement('div');
	TrainListElement.appendChild(TrainElement);
	
	TrainData.push(Train);
	
	
	//	save references
	TrainElement.Train = Train;
	Train.Element = TrainElement;
}

function SortDomNodes()
{
	const TrainListElement = document.querySelector('#TrainList');
	
	function SortTrainElement(a,b)
	{
		const ta = a.Train;
		const tb = b.Train;
		if ( ta.ArrivalTime < tb.ArrivalTime )
			return -1;
		if ( ta.ArrivalTime > tb.ArrivalTime )
			return 1;
		return 0;
	}
	
	//	get an array of child nodes, sort them, then re-add in order
	const Children = [...TrainListElement.children];
	Children.sort( SortTrainElement ).forEach( e => TrainListElement.appendChild(e) );
}

function UpdateDomNodes()
{
	function UpdateTrainElement(TrainElement)
	{
		const Train = TrainElement.Train;
		const NowSecs = GetTimeNowSecs();
		const TrainLeaveTime = (Train.ArrivalTime + TrainWaitTimeSecs);
		const Expired = TrainLeaveTime <= NowSecs;
		const Arrived = Train.ArrivalTime <= NowSecs && TrainLeaveTime > NowSecs;
		const New = Train.AddedTime > (NowSecs - TrainNewTimeSecs);
		Expired ? TrainElement.setAttribute('Expired',Expired) : TrainElement.removeAttribute('Expired');
		Arrived ? TrainElement.setAttribute('Arrived',Arrived) : TrainElement.removeAttribute('Arrived');
		New ? TrainElement.setAttribute('New',New) : TrainElement.removeAttribute('New');
	
		const TimeToArrive = Train.ArrivalTime - NowSecs;
		const TimeToArriveString = (TimeToArrive>0) ? TimeToArrive : ''; 
		TrainElement.setAttribute('Station',Train.Station);
		TrainElement.setAttribute('Line',Train.Line);
		TrainElement.setAttribute('SecsToArrive',TimeToArriveString);
		TrainElement.setAttribute('PredictionId',Train.PredictionId);

		const DisplayString = `${Train.Station}`;
		if ( TrainElement.InnerTextCache != DisplayString )
		{
			TrainElement.innerText = DisplayString;
			TrainElement.InnerTextCache = DisplayString;
		}
	}
	
	const TrainListElement = document.querySelector('#TrainList');
	const Children = [...TrainListElement.children];
	Children.forEach(UpdateTrainElement);
}

async function CheckStationHasTrains(StationCode)
{
	const StopPoint = StationStopPoints[StationCode];
	const Url = `https://api.tfl.gov.uk/StopPoint/${StopPoint}`;

	const FetchParams = {};
	FetchParams.mode = 'cors';
	const Response = await fetch( Url, FetchParams );
	const Json = await Response.json();

	const MatchingModes = Json.modes.filter( Mode => ModeNames.indexOf(Mode)!= -1);
	if ( MatchingModes.length == 0 )
		throw `${StationCode} doesn't have underground trains, only; ${Json.modes.join(',')}`;

	console.log(`${StationCode} supports ${MatchingModes.join(',')}`);
	return Json;
}

async function RefreshStation(StationCode)
{
	const TimeSecs = GetTimeNowSecs();
	const Json = await GetStationJson(StationCode);
	const Trains = await GetStationTrains(Json,StationCode,TimeSecs);
	
	//	throw an error if we query a station with no tube trains
	if ( !Trains.length )
	{
		await CheckStationHasTrains(StationCode);
	}
	
	Trains.forEach( PushTrainData );
	SortDomNodes();
}


function ShowInfo(Info)
{
	if ( !Info )
		Info = '';
	
	const InfoBox = document.querySelector('.InfoBox');
	InfoBox.innerText = Info;
}

async function RefreshStations()
{
	let CurrentIndex = 0;

	async function WaitSecs(Secs)
	{
		for ( let i=0;	i<Secs;	i++ )
		{
			UpdateDomNodes();
			await Pop.Yield( 1*1000 );
		}
		UpdateDomNodes();
	}
	
	//	for debugging shuffle the order we fetch
	let StationNames = Object.keys(StationStopPoints);
	//Pop.ShuffleArray(StationNames);

	while(true)
	{
		const CurrentStation = StationNames[CurrentIndex];
		try
		{
			ShowInfo(`Fetching ${StationFormattedNames[CurrentStation]}...`);
			await RefreshStation(CurrentStation);
			//ShowInfo(null);
			UpdateDomNodes();
		}
		catch(e)
		{
			console.error(`Refreshing station ${CurrentStation} error: ${e}`);
			ShowInfo(`Refreshing station ${CurrentStation} error: ${e}`);
			//await WaitSecs(1);
		}
		CurrentIndex = (CurrentIndex+1) % StationNames.length;
		await WaitSecs(ThrottleUpdateNextSecs);
		
		if ( CurrentIndex == 0 )
		{
			console.log(`Updated all trains`);
			await WaitSecs(ThrottleUpdateAllSecs);
		}
	}
}

RefreshStations().catch(ShowInfo);

</script>

</body>
</html>
